name: Build TCMT Windows Client

on:
  push:
    branches: [ main, dev, feature/iflow-cli-integration ]
  pull_request:
    branches: [ main, dev, feature/iflow-cli-integration ]
  workflow_dispatch:

env:
  SOLUTION_FILE_PATH: Project1/Project1.sln
  BUILD_CONFIGURATION: Release
  BUILD_PLATFORM: x64

jobs:
  full-build:
    runs-on: windows-latest
    steps:
    - uses: actions/checkout@v5
      with:
        ref: dev
        submodules: recursive
        fetch-depth: 0

    ### S.A.E.R 环境报告
    - name: Generate S.A.E.R System Report
      id: report
      shell: pwsh
      run: |
        echo "=== SYSTEM AND ENVIRONMENT REPORT ===" | Out-File saer.txt
        Get-CimInstance -ClassName Win32_ComputerSystem | Select-Object TotalPhysicalMemory, @{Name="RAM(GB)"; Expression={[math]::Round($_.TotalPhysicalMemory / 1GB, 2)}} | Format-Table | Out-File -FilePath saer.txt -Append
        Get-CimInstance -ClassName Win32_Processor | Select-Object Name,NumberOfCores,NumberOfLogicalProcessors,MaxClockSpeed | Format-Table | Out-File -FilePath saer.txt -Append
        Get-ChildItem Env: | Where-Object { $_.Name -match "PATH|CUDA|MSBUILD|VISUAL" } | Select-Object Name, Value | Format-Table | Out-File saer.txt -Append
        git --version | Out-File saer.txt -Append

    - name: Upload S.A.E.R Report
      uses: actions/upload-artifact@v4
      with:
        name: saer-report
        path: saer.txt

    ### 环境装配
    - name: Setup .NET
      uses: actions/setup-dotnet@v5
      with:
        dotnet-version: '8.x'

    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2

    #### CUDA缓存+下载
    - name: Cache CUDA
      id: cache-cuda
      uses: actions/cache@v4
      with:
        path: C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.6
        key: cuda-12.6-${{ runner.os }}

    - name: Setup CUDA 12.6
      if: steps.cache-cuda.outputs.cache-hit != 'true'
      uses: Jimver/cuda-toolkit@v0.2.18
      with:
        cuda: '12.6.0'
        method: 'network'

    #### NuGet包和MSBuild缓存
    - name: Cache NuGet packages
      id: cache-nuget
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        key: nuget-${{ runner.os }}-${{ hashFiles('**/*.sln','**/*.csproj','**/packages.config') }}
        restore-keys: |
          nuget-${{ runner.os }}-

    - name: NuGet restore
      shell: pwsh
      run: |
        nuget restore ${{ env.SOLUTION_FILE_PATH }}
        dotnet restore ${{ env.SOLUTION_FILE_PATH }}

    - name: Cache MSBuild
      uses: actions/cache@v4
      with:
        path: C:\Program Files (x86)\Microsoft Visual Studio\2022\Enterprise\MSBuild
        key: msbuild-${{ runner.os }}-${{ hashFiles('**/*.sln') }}
        restore-keys: |
          msbuild-${{ runner.os }}-

    #### iflow-cli缓存+下载/安装
    - name: Cache iflow-cli
      id: cache-iflow
      uses: actions/cache@v4
      with:
        path: C:\npm\prefix\node_modules\@iflow-ai\iflow-cli
        key: iflow-cli-${{ runner.os }}-v2.0.0

    - name: Install iflow-cli
      shell: pwsh
      run: |
        # 如果缓存未命中，则安装
        if ("${{steps.cache-iflow.outputs.cache-hit}}" -eq "true") {
          Write-Host "已命中iflow-cli缓存，跳过安装"
        } else {
          Write-Host "未命中iflow-cli缓存，执行安装"
          npm install -g @iflow-ai/iflow-cli
        }
        iflow --version

    ### 编译各模块
    - name: Build LibreHardwareMonitor
      shell: pwsh
      run: |
        cd src/third_party/LibreHardwareMonitor
        dotnet build LibreHardwareMonitorLib/LibreHardwareMonitorLib.csproj -c Release -f net472 --no-restore 2>&1 | Tee-Object -FilePath build_lib.log
    - name: Upload LibreHardwareMonitor Build Log
      uses: actions/upload-artifact@v4
      with:
        name: lib-build-log
        path: src/third_party/LibreHardwareMonitor/build_lib.log

    - name: Build WPF-UI1
      shell: pwsh
      run: |
        cd WPF-UI1
        dotnet build WPF-UI1.csproj -c Release --no-restore 2>&1 | Tee-Object -FilePath wpfui1_build.log
    - name: Upload WPF-UI1 Build Log
      uses: actions/upload-artifact@v4
      with:
        name: wpf-build-log
        path: WPF-UI1/wpfui1_build.log

    - name: Build CPP-parsers
      shell: pwsh
      run: |
        msbuild src/CPP-parsers/CPP-parsers/CPP-parsers.vcxproj /p:Configuration=Release /p:Platform=x64 /p:PlatformToolset=v143 /p:WindowsTargetPlatformVersion=10.0 /m /verbosity:minimal 2>&1 | Tee-Object -FilePath cpp_parsers_build.log
    - name: Upload CPP-parsers Build Log
      uses: actions/upload-artifact@v4
      with:
        name: cpp-build-log
        path: cpp_parsers_build.log

    - name: Build Main Project
      shell: pwsh
      run: |
        msbuild ${{ env.SOLUTION_FILE_PATH }} /p:Configuration=${{ env.BUILD_CONFIGURATION }} /p:Platform=${{ env.BUILD_PLATFORM }} /p:PlatformToolset=v143 /p:WindowsTargetPlatformVersion=10.0 /m /verbosity:minimal 2>&1 | Tee-Object -FilePath main_build.log
        # 扫描致命错误
        $lines = Get-Content main_build.log | Select-String -Pattern "${{ env.FAIL_ERROR_REGEX }}"
        $lines = $lines | Where-Object { $_.Line -notmatch '0 Error\\(s\\)' }
        if ($lines){
          Set-Content main_build.errors.txt ($lines | ForEach-Object {$_.Line} | Out-String)
          exit 1
        } else {
          Set-Content main_build.errors.txt "未发现致命错误(main_build)。"
        }
    - name: Upload Main Build Log
      uses: actions/upload-artifact@v4
      with:
        name: main-build-log
        path: |
          main_build.log
          main_build.errors.txt

    ### iFlow分析阶段
    - name: Run iFlow CLI Analysis
      uses: iflow-ai/iflow-cli-action@v2.0.0
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        REPOSITORY: ${{ github.repository }}
        PR_NUMBER: ${{ github.event.pull_request.number }}
        RUN_ID: ${{ github.run_id }}
      with:
        api_key: ${{ secrets.IFLOW_API_KEY }}
        model: "Qwen3-Coder"
        timeout: "1800"
        working_directory: "."
        prompt: |
          ## Role
          你是一个CI/CD智能决策助手，负责分析代码变更并制定最优的编译策略。
          ## 任务
          1. 分析当前代码变更情况
          2. 根据变更内容决定哪些模块需要编译
          3. 评估缓存策略的有效性
          4. 制定编译优先级和依赖关系
          ## 步骤
          1. 运行 `git diff --name-only HEAD~1 HEAD` 获取变更文件
          2. 分析变更文件对应的模块：
             - src/core/ 或 src/main.cpp → cpp模块需要编译
             - WPF-UI1/ → wpf模块需要编译
             - src/third_party/ → lib模块需要编译
          ## 注意事项
          - 优先考虑编译效率和资源利用
          - 确保依赖关系正确

    - name: Upload Build Decision
      uses: actions/upload-artifact@v4
      with:
        name: build-decision
        path: build_decision.json

  # === 并行组4: 智能编译 ===
  build-lib:
    name: Build LibreHardwareMonitor
    runs-on: windows-latest
    needs: [setup-nuget]
    steps:
    - uses: actions/checkout@v5
      with:
        ref: dev
        submodules: recursive
        fetch-depth: 0
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v5
      with:
        dotnet-version: '8.x'
    
    - name: Build LibreHardwareMonitor
      run: |
        cd src/third_party/LibreHardwareMonitor
        dotnet build LibreHardwareMonitorLib/LibreHardwareMonitorLib.csproj -c Release -f net472 --no-restore 2>&1 | Tee-Object -FilePath build_lib.log
    
    - name: Upload Build Log
      uses: actions/upload-artifact@v4
      with:
        name: lib-build-log
        path: build_lib.log

  build-wpf:
    name: Build WPF-UI1
    runs-on: windows-latest
    needs: [setup-nuget]
    steps:
    - uses: actions/checkout@v5
      with:
        ref: dev
        submodules: recursive
        fetch-depth: 0
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v5
      with:
        dotnet-version: '8.x'
    
    - name: Build WPF-UI1
      run: |
        cd WPF-UI1
        dotnet build WPF-UI1.csproj -c Release --no-restore 2>&1 | Tee-Object -FilePath wpfui1_build.log
    
    - name: Upload Build Log
      uses: actions/upload-artifact@v4
      with:
        name: wpf-build-log
        path: wpfui1_build.log

  build-cpp:
    name: Build CPP-parsers
    runs-on: windows-latest
    needs: [setup-msbuild]
    steps:
    - uses: actions/checkout@v5
      with:
        ref: dev
        submodules: recursive
        fetch-depth: 0
    
    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2
    
    - name: Build CPP-parsers
      run: |
        msbuild src/CPP-parsers/CPP-parsers/CPP-parsers.vcxproj /p:Configuration=Release /p:Platform=x64 /p:PlatformToolset=v143 /p:WindowsTargetPlatformVersion=10.0 /m /verbosity:minimal 2>&1 | Tee-Object -FilePath cpp_parsers_build.log
    
    - name: Upload Build Log
      uses: actions/upload-artifact@v4
      with:
        name: cpp-build-log
        path: cpp_parsers_build.log

  build-main:
    name: Build Main Project
    runs-on: windows-latest
    needs: [setup-nuget, setup-msbuild, setup-cuda, build-lib, build-wpf, build-cpp]
    steps:
    - uses: actions/checkout@v5
      with:
        ref: dev
        submodules: recursive
        fetch-depth: 0
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v5
      with:
        dotnet-version: '8.x'
    
    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2
    
    - name: Restore solution
      run: |
        nuget restore ${{ env.SOLUTION_FILE_PATH }}
        dotnet restore ${{ env.SOLUTION_FILE_PATH }}
    
    - name: Build main project
      run: |
        msbuild ${{ env.SOLUTION_FILE_PATH }} /p:Configuration=${{ env.BUILD_CONFIGURATION }} /p:Platform=${{ env.BUILD_PLATFORM }} /p:PlatformToolset=v143 /p:WindowsTargetPlatformVersion=10.0 /m /verbosity:minimal 2>&1 | Tee-Object -FilePath main_build.log
        
        # 扫描致命错误
        $lines = Get-Content main_build.log | Select-String -Pattern "${{ env.FAIL_ERROR_REGEX }}"
        $lines = $lines | Where-Object { $_.Line -notmatch '0 Error\(s\)' }
        if ($lines){
          Set-Content main_build.errors.txt ($lines | ForEach-Object {$_.Line} | Out-String)
          exit 1
        } else {
          Set-Content main_build.errors.txt "未发现致命错误(main_build)。"
        }
    
    - name: Upload Build Log
      uses: actions/upload-artifact@v4
      with:
        name: main-build-log
        path: |
          main_build.log
          main_build.errors.txt

  # === 并行组5: 测试运行（1分钟限时） ===
  test-application:
    name: Test Application (1min limited)
    runs-on: windows-latest
    needs: build-main
    timeout-minutes: 1
    continue-on-error: true
    steps:
    - uses: actions/checkout@v5
      with:
        ref: dev
        submodules: recursive
        fetch-depth: 0
    
    - name: Download all build artifacts
      uses: actions/download-artifact@v4
      with:
        pattern: "*-build-log"
        merge-multiple: true
    
    - name: Test Application
      run: |
        # 查找主程序
        $exeToRun = $null
        if ($env:MAIN_EXE -and (Test-Path "Project1/x64/${{ env.BUILD_CONFIGURATION }}/$($env:MAIN_EXE)")) {
          $exeToRun = (Get-Item "Project1/x64/${{ env.BUILD_CONFIGURATION }}/$($env:MAIN_EXE)").FullName
        } else {
          $exes = Get-ChildItem -Path "Project1/x64/${{ env.BUILD_CONFIGURATION }}" -Filter *.exe | Where-Object { $_.Name -notmatch 'vshost' }
          if ($exes) {
            $exeToRun = $exes[0].FullName
          }
        }
        
        if ($exeToRun) {
          Write-Host "Starting application: $exeToRun"
          Start-Process -FilePath $exeToRun
          Start-Sleep -Seconds 30
          
          # 截图
          Add-Type -AssemblyName System.Windows.Forms
          Add-Type -AssemblyName System.Drawing
          $bounds = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds
          $bitmap = New-Object System.Drawing.Bitmap $bounds.Width, $bounds.Height
          $graphics = [System.Drawing.Graphics]::FromImage($bitmap)
          $graphics.CopyFromScreen($bounds.Location, [System.Windows.Point]::Empty, $bounds.Size)
          $bitmap.Save("test_screenshot.png")
          $graphics.Dispose(); $bitmap.Dispose()
          
          Write-Host "Application test completed"
        } else {
          Write-Host "No executable found for testing"
        }
    
    - name: Upload Test Results
      uses: actions/upload-artifact@v4
      with:
        name: test-results
        path: test_screenshot.png

  # === 并行组6: iflow-cli编译总结 ===
  iflow-summary:
    name: iFlow CLI Summary
    runs-on: windows-latest
    needs: [iflow-analysis, build-lib, build-wpf, build-cpp, build-main, test-application]
    if: always()
    steps:
    - uses: actions/checkout@v5
      with:
        ref: dev
        submodules: recursive
        fetch-depth: 0
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v5
      with:
        dotnet-version: '8.x'
    
    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2
    
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        merge-multiple: true
    
    - name: Run iFlow CLI Summary
      uses: iflow-ai/iflow-cli-action@v2.0.0
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        REPOSITORY: ${{ github.repository }}
        PR_NUMBER: ${{ github.event.pull_request.number }}
        RUN_ID: ${{ github.run_id }}
        BUILD_STATUS: ${{ job.status }}
      with:
        api_key: ${{ secrets.IFLOW_API_KEY }}
        model: "Qwen3-Coder"
        timeout: "1200"
        working_directory: "."
        prompt: |
          ## Role
          你是一个CI/CD结果总结助手，负责分析编译结果并生成专业的总结报告。
          ## 任务
          1. 分析所有构建日志
          2. 评估编译成功率和质量
          3. 识别关键问题和建议
          4. 生成结构化的总结报告
          ## 步骤
          1. 分析 build_lib.log、wpfui1_build.log、cpp_parsers_build.log、main_build.log、saer.txt
          2. 生成 build_summary.json 并提供人类可读总结文本
          ## 注意事项
          - 优先识别阻塞性错误
          - 提供具体的修复建议

    - name: Upload Summary
      uses: actions/upload-artifact@v4
      with:
        name: build-summary
        path: build_summary.json

    ### PR反馈推送 by iflow-summary
    - name: PR Feedback
      if: github.event_name == 'pull_request'
      shell: pwsh
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        REPOSITORY: ${{ github.repository }}
        PR_NUMBER: ${{ github.event.pull_request.number }}
        RUN_ID: ${{ github.run_id }}
      run: |
        if (Test-Path "build_summary.json") {
          $summaryJson = Get-Content "build_summary.json" | ConvertFrom-Json
          $comment = $summaryJson.summary_text # summary_text 是 iFlow CLI 提供的人类可读总结
        } else {
          $comment = "本次编译流程未能获得Ifow总结数据，请检查 workflow 日志。"
        }
        $headers = @{
          Authorization = "token $env:GITHUB_TOKEN"
          "User-Agent" = "github-actions-powershell"
          "Accept" = "application/vnd.github+json"
        }
        $body = @{ body = $comment } | ConvertTo-Json -Depth 4
        $repo = $env:REPOSITORY
        $prNumber = $env:PR_NUMBER
        $url = "https://api.github.com/repos/$repo/issues/$prNumber/comments"
        Invoke-RestMethod -Uri $url -Method Post -Headers $headers -Body $body